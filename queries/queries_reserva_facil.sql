/*
BD TRABALHO FINAL
*/

-- TABELAS UTILIZADAS NA APLICA��O


-- public.tb_alunos definition

CREATE TABLE public.tb_alunos (
	matricula int8 NOT NULL,
	curso int2 NOT NULL,
	data_nascimento date NOT NULL,
	nome varchar(100) NOT NULL,
	CONSTRAINT tb_alunos_curso_check CHECK (((curso >= 0) AND (curso <= 14))),
	CONSTRAINT tb_alunos_pkey PRIMARY KEY (matricula)
);
-- public.tb_disciplinas definition

CREATE TABLE public.tb_disciplinas (
	codigo int8 NOT NULL,
	curso int2 NOT NULL,
	nome varchar(100) NOT NULL,
	id int8 NULL,
	CONSTRAINT tb_disciplinas_curso_check CHECK (((curso >= 0) AND (curso <= 14))),
	CONSTRAINT tb_disciplinas_pkey PRIMARY KEY (codigo),
	CONSTRAINT fko4fxm4mwah2fiw8nky12nq0si FOREIGN KEY (id) REFERENCES public.tb_professores(id)
);
-- public.tb_laboratorios definition


CREATE TABLE public.tb_laboratorios (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	capacidade_maxima int4 NOT NULL,
	nome varchar(255) NOT NULL,
	predio int4 NOT NULL,
	sala int4 NOT NULL,
	CONSTRAINT tb_laboratorios_pkey PRIMARY KEY (id),
	CONSTRAINT ukkp8ev5wn8vsp4213mtr5qex16 UNIQUE (nome)
);
-- public.tb_matriculas definition

CREATE TABLE public.tb_matriculas (
	matricula int8 NOT NULL,
	codigo int8 NOT NULL,
	CONSTRAINT tb_matriculas_pkey PRIMARY KEY (matricula, codigo),
	CONSTRAINT fkafsfbw2wpojwij2danubvkjar FOREIGN KEY (matricula) REFERENCES public.tb_alunos(matricula),
	CONSTRAINT fkgwyc41pfritpyxn9xalvtdw2g FOREIGN KEY (codigo) REFERENCES public.tb_disciplinas(codigo)
);
-- public.tb_professores definition


CREATE TABLE public.tb_professores (
	id int8 NOT NULL,
	data_nascimento date NOT NULL,
	especialidade int2 NOT NULL,
	"name" varchar(255) NOT NULL,
	CONSTRAINT tb_professores_especialidade_check CHECK (((especialidade >= 0) AND (especialidade <= 14))),
	CONSTRAINT tb_professores_pkey PRIMARY KEY (id)
);
-- public.tb_reservas definition

CREATE TABLE public.tb_reservas (
	agendamento timestamp(6) NOT NULL,
	codigo_disciplina int8 NOT NULL,
	id_laboratorio int8 NOT NULL,
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	CONSTRAINT tb_reservas_pkey PRIMARY KEY (agendamento, codigo_disciplina, id_laboratorio)
);

-- ========================================================================

-- TRIGGERS
-- 1. Horário das reservas deve ser feito entre 07:00 e 23:00

CREATE OR REPLACE FUNCTION validar_horario_reserva()
RETURNS TRIGGER AS $$
BEGIN
    IF EXTRACT(HOUR FROM NEW.agendamento) >= 23 OR EXTRACT(HOUR FROM NEW.agendamento) < 7 THEN
        RAISE EXCEPTION 'As reservas devem ser feitas entre 23:00 e 07:00.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_horario_reserva
BEFORE INSERT OR UPDATE ON tb_reservas
FOR EACH ROW EXECUTE FUNCTION validar_horario_reserva();


-- 2. Limite de pessoas por disciplina (30)

CREATE OR REPLACE FUNCTION validar_limite_alunos_disciplina()
RETURNS TRIGGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM tb_matriculas
    WHERE codigo = NEW.codigo;

    IF v_count >= 30 THEN
        RAISE EXCEPTION 'O limite de 30 alunos por disciplina foi atingido.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_limite_alunos_disciplina
BEFORE INSERT ON tb_matriculas
FOR EACH ROW EXECUTE FUNCTION validar_limite_alunos_disciplina();


-- 3. DT_NASCIMENTO > 17 anos (2009) e DT_NASCIMENTO < 90

CREATE OR REPLACE FUNCTION validar_data_nascimento_aluno()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.data_nascimento > CURRENT_DATE - INTERVAL '17 years' OR
       NEW.data_nascimento < CURRENT_DATE - INTERVAL '90 years' THEN
        RAISE EXCEPTION 'A idade deve estar entre 17 e 90 anos.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_data_nascimento_aluno
BEFORE INSERT OR UPDATE ON tb_alunos
FOR EACH ROW EXECUTE FUNCTION validar_data_nascimento_aluno();


-- 4. Um laboratorio só pode ser criado se tiver espaço para no minimo 10 pessoas e no máximo 30 pessoas

CREATE OR REPLACE FUNCTION validar_capacidade_laboratorio_criacao()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.capacidade_maxima < 10 OR NEW.capacidade_maxima > 30 THEN
        RAISE EXCEPTION 'A capacidade do laboratório deve ser entre 10 e 30.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_capacidade_laboratorio_criacao
BEFORE INSERT OR UPDATE ON tb_laboratorios
FOR EACH ROW EXECUTE FUNCTION validar_capacidade_laboratorio_criacao();


-- 5. Proibir reserva s�bado e domingo 

CREATE OR REPLACE FUNCTION validar_reservas_dias_uteis()
RETURNS TRIGGER AS $$
BEGIN
    IF EXTRACT(DOW FROM NEW.agendamento) IN (0, 6) THEN
        RAISE EXCEPTION 'Reservas não são permitidas aos sábados e domingos.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_reservas_dias_uteis
BEFORE INSERT OR UPDATE ON tb_reservas
FOR EACH ROW EXECUTE FUNCTION validar_reservas_dias_uteis();


-- 6. Impedir a exclusão de laboratórios que possuem reservas futuras

CREATE OR REPLACE FUNCTION validar_exclusao_laboratorio_reservas()
RETURNS TRIGGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM tb_reservas
    WHERE id_laboratorio = OLD.id
      AND agendamento > NOW();

    IF v_count > 0 THEN
        RAISE EXCEPTION 'Não é possível excluir laboratórios com reservas futuras.';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_exclusao_laboratorio_reservas
BEFORE DELETE ON tb_laboratorios
FOR EACH ROW EXECUTE FUNCTION validar_exclusao_laboratorio_reservas();


-- 7. Validar a idade m�nima para um professor

CREATE OR REPLACE FUNCTION validar_idade_minima_professor()
RETURNS TRIGGER AS $$
BEGIN
    IF AGE(NOW(), NEW.data_nascimento) < INTERVAL '25 years' THEN
        RAISE EXCEPTION 'O professor deve ter pelo menos 25 anos.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_idade_minima_professor
BEFORE INSERT OR UPDATE ON tb_professores
FOR EACH ROW EXECUTE FUNCTION validar_idade_minima_professor();


-- 8. Impedir a exclusão de disciplinas com reservas associadas

CREATE OR REPLACE FUNCTION validar_exclusao_disciplina_reservas()
RETURNS TRIGGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM tb_reservas
    WHERE codigo_disciplina = OLD.codigo;

    IF v_count > 0 THEN
        RAISE EXCEPTION 'Não é possível excluir disciplinas com reservas associadas.';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_exclusao_disciplina_reservas
BEFORE DELETE ON tb_disciplinas
FOR EACH ROW EXECUTE FUNCTION validar_exclusao_disciplina_reservas();


--9. Impedir a inserção de reservas para disciplinas sem um professor atribuído

CREATE OR REPLACE FUNCTION validar_disciplina_professor()
RETURNS TRIGGER AS $$
DECLARE
    v_professor INTEGER;
BEGIN
    SELECT id INTO v_professor
    FROM tb_disciplinas
    WHERE codigo = NEW.codigo_disciplina;

    IF v_professor IS NULL THEN
        RAISE EXCEPTION 'A disciplina deve ter um professor atribuído para reservas.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_disciplina_professor
BEFORE INSERT OR UPDATE ON tb_reservas
FOR EACH ROW EXECUTE FUNCTION validar_disciplina_professor();


--10. Impedir a criação de dois laboratorios com mesma sala e predio

CREATE OR REPLACE FUNCTION validar_laboratorio_unico()
RETURNS TRIGGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM tb_laboratorios
    WHERE predio = NEW.predio
      AND sala = NEW.sala
      AND id != NEW.id;

    IF v_count > 0 THEN
        RAISE EXCEPTION 'Já existe um laboratório cadastrado neste prédio e sala.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validar_laboratorio_unico
BEFORE INSERT OR UPDATE ON tb_laboratorios
FOR EACH ROW EXECUTE FUNCTION validar_laboratorio_unico();

-- ========================================================================

-- Consulta com Inner join em pelo menos 2 tabelas:

SELECT r.id,
    r.agendamento AS horario,
    r.codigo_disciplina,
    r.id_laboratorio,
    l.nome AS laboratorio,
    l.predio AS predio,
    l.sala AS sala,
    d.nome AS disciplina
FROM tb_reservas r
INNER JOIN tb_laboratorios l ON r.id_laboratorio = l.id
INNER JOIN tb_disciplinas d ON r.codigo_disciplina = d.codigo
ORDER BY r.id;



-- LEFT JOIN para buscar laboratórios sem reservas:
SELECT l.id,
        l.nome,
        l.capacidade_maxima as capacidadeMaxima,
        l.predio,
        l.sala
FROM tb_laboratorios l
LEFT JOIN tb_reservas r ON l.id = r.id_laboratorio
WHERE r.id_laboratorio IS NULL; 

-- GROUP BY PRA OBTER QUANTIDADE ALUNOS POR DISCIPLINA
SELECT d.codigo,
        d.nome,
        d.id as professorId,
        COUNT(m.matricula) AS qntdAlunos
FROM tb_disciplinas d
LEFT JOIN tb_matriculas m ON d.codigo = m.codigo
GROUP BY d.codigo;

-- GROUP BY COM HAVING PARA LISTAR DISCIPLINAS COM CAPACIDADE MAXIMA DE ALUNOS
SELECT d.codigo,
        d.nome,
        d.id as professorId,
        COUNT(m.matricula) AS qntdAlunos
FROM tb_disciplinas d
LEFT JOIN tb_matriculas m ON d.codigo = m.codigo
GROUP BY d.codigo
HAVING COUNT(m.matricula) = 30;

-- SUBCONSULTA PARA BUSCAR MATRICULAS CADASTRADAS NO SISTEMA:
SELECT al.matricula as matricula,
    al.NOME AS nomeAluno,
    d.codigo as codigoDisciplina,
    d.NOME AS NOME_DISCIPLINA
                FROM TB_ALUNOS al, TB_DISCIPLINAS d
                WHERE EXISTS (
                    SELECT 1
                    FROM tb_matriculas apd
                    WHERE apd.MATRICULA = al.MATRICULA
                    AND apd.CODIGO = d.CODIGO
                );